/* 
  Стрелочные функции:
    • Имеют более короткий синтаксис.
    • Выражение стрелочных функций не позволяют задавать имя,
    поэтому стрелочные функции анонимны, если их ни к чему не
    присвоить.
    • Тело стрелочной функции может иметь краткую (concise body)
    или блочную (block body) форму. Блочная форма не возвращает
    значение, необходимо явно вернуть значение.
    • Стрелочные функции не содержат собственный контекст this, а
    используют значение this окружающего контекста.
        const obj = {
          a: 1,
          b: 2,
          getContext: () => console.log(this),
          getContext1: function() {console.log(this)},
        }
    • Стрелочные функции не могут быть использованы как
    конструктор и вызовут ошибку при использовании с new.
*/

// Task: написать функцию declaration: getSum(a, b) ---> сумму чисел 

/*  
  Функции обратного вызова:
    • Функция обратного вызова - это функция, переданная в другую
    функцию в качестве аргумента, которая затем вызывается по
    завершению какого-либо действия.
    • Функция обратного вызова позволяет нам быть уверенными в
    том, что определенный код не начнет исполнение до того
    момента, пока другой код не завершит исполнение.
*/

// Task: написать arrow функции:
  // getSum(a, b) ---> сумму чисел 
  // showCount(fn, x, y) ---> принимает три параметра и выводит в консоль сумму чисел

const numbers = [5, 43, 63, 23, 90];

const newNumbers = numbers.map((el, i) =>{ 
  return el += 5
})

console.log({ numbers, newNumbers });
/*
  Методы массивов:
    • forEach - выполняет функцию callback один раз для каждого
    элемента, находящегося в массиве в порядке возрастания. Она
    не будет вызвана для удалённых или пропущенных элементов
    массива.

  

    // Task: const numbers = [5, 43, 63, 23, 90]; ---> добавить каждому элементу значек $
    // Expected result: [5$, 43$, 63$, 23$, 90$]; 
  
    • map - вызывает переданную функцию callback один раз для
    каждого элемента, в порядке их появления и конструирует
    новый массив из результатов её вызова.

    // Task: const names = ["Artur", "Oleg", "Elena", "Olga", "Denis"];
    // Expected result: ["name: Artur", "name: Oleg", "name: Elena", "name: Olga", "name: Denis"]; 

    • reduce - выполняет функцию callback один раз для каждого
    элемента, присутствующего в массиве, принимая четыре
    аргумента: начальное значение (или значение от предыдущего
    вызова callback), значение текущего элемента, текущий индекс и
    массив, по которому происходит итерация.

    // Task: update hw6 - 9;
    // Expected result: 100485; 

    • filter - вызывает переданную функцию callback один раз для
    каждого элемента, присутствующего в массиве, и конструирует
    новый массив со всеми значениями, для которых
    функция callback вернула true

    // Task: get positive numbers const mixedNumbers = [-14, 24, -89, 43, 0, -1, 412, 4];
    // Expected result: [24, 43, 0, 412, 4]; 

    • find - вызывает переданную функцию callback один раз для
    каждого элемента, присутствующего в массиве, до тех пор, пока
    она не вернёт true. Если такой элемент найден,
    метод find немедленно вернёт значение этого элемента. В
    противном случае, метод find вернёт undefined.

    // Task: find number 43 const mixedNumbers = [-14, 24, -89, 43, 0, -1, 412, 4];
    // Expected result: 43; 
*/

/*
  Немедленно вызываемые функции:
    • IIFE (Immediately Invoked Function Expression)
    это JavaScript функция, которая выполняется сразу же после
    того, как она была определена.
    • Состоит из двух частей - оператора группировки и вызова
    выражения.
*/

/*
  Функции конструкторы:
    • Если нам нужно создать множество однотипных объектов мы
    можем воспользоваться функциями конструкторами.
    • Имя функции-конструктора должно начинаться с большой
    буквы.
    • Функция-конструктор должна вызываться при помощи
    оператора “new"
    • Оператор new создает экземпляр объекта.
    • Задача функции конструктора создать экземпляр объекта, а не
    возвращать явно какой-то результат.
    • В this мы можем добавлять не только свойства, но и методы.
*/


    // Task: 
      // Создать функцию конструктор:
        // new User(name, age, fn);
        // есть свойства name, age и методы getYearOfBirthday 
        // (использовать const currentYear = new Date().getFullYear()), 
        // showYearOfBirthday
        // на верхнем уровне создать функцию showYear() которая будет 
        // выводить в консоль год рождения юзера


// const showInfo = () => 
//   console.log(
//   `${this.name} ${this.lastName} проживает по адресу ${this.address} и ему ${this.age} лет/год(a)`
// );

// function showInfo() { 
//   console.log(
//   `${this.name} ${this.lastName} проживает по адресу ${this.address} и ему ${this.age} лет/год(a)`
// )};

// function User(name, lastName, age, address) {
//   this.name = name;
//   this.lastName = lastName;
//   this.age = age;
//   this.address = address;
//   this.showInfo = showInfo;
// };

// const user1 = new User('Igor', 'Petrov', 25, 'Minsk, Lenina str');
// const user2 = new User('Oleg', 'Ivanov', 32, 'Minsk, Soltisa str');

// user1.showInfo();
// user2.showInfo();

// const currentYear = new Date().getFullYear()
// console.log(currentYear);